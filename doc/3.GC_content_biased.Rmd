---
title: "3. GC biased gene sets"
output:
  html_document:
    df_print: paged
---


```{r setup, include=FALSE}
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

```{r, include = FALSE}
# my laptop doesn't really like working on the network from home, it's better to 
# copy the files to the computer and access them from there. This should make it 
# easier to switch between
using_laptop <- FALSE
```

```{r}
library("devtools")
ifelse(using_laptop,
       load_all("C:/Users/bigginsl/Desktop/temp/GOcategoryStats"),
       load_all("M:/GOcategoryStats")
       )
par(mgp = c(2, 0.5, 0))
par(mar = par()$mar * 0.7)

library(RColorBrewer)
palette(brewer.pal(6, "Set2"))

genome <- "Mus_musculus.GRCm38.94"
```

####Creating lists of mouse genes biased by GC content.
To generate the lists, a file containing the GC content of all the genes in the
mouse genome is required.


We're only doing high and low GC content, I've previously looked at other GC 
intervals and didn't find any biases.

##Pre-processing of data on cluster

The script create_gene_info_file_from_gtf.pl takes a gtf file and parses it to
create a gene info file that contains all the genes that are annotated in the 
gtf file. This should be all the genes in that version of the genome.


/bi/group/bioinf/Laura_B/bias_analysis/in_silico/in_silico_datasets/GC

Downloaded the raw version of the file from github
`wget https://raw.githubusercontent.com/s-andrews/GOliath/master/processing/`
`gene_info_processing/create_gene_info_file_from_gtf.pl`

Run this script to create the gene info file
`perl create_gene_info_file_from_gtf.pl --gtf Mus_musculus.GRCm38.94.gtf.gz --genome GRCm38`

We'll import the gene info file so that we can plot the GC distribution for all 
genes in the Mus_musculus.GRCm38.94.gtf.gz genome.
There are import_GTF and parse_GTF_info functions within the GOcategoryStats 
package but to get genome information i.e. GC content, the parsing and lookups 
need to be done with access to genome information, so on the cluster. 
The import_GTF and parse_GTF_info functions just work with the gtf file itself.


Plot out the GC distribution for all the genes in Mus_musculus.GRCm38.94
```{r}
x <- ifelse(using_laptop,
       genfo <- read.delim("C:/Users/bigginsl/Desktop/temp//biased_gene_lists/Mus_musculus.GRCm38.94_gene_info.txt"),
       genfo <- read.delim("M:/biased_gene_lists/Mus_musculus.GRCm38.94_gene_info.txt")
)
bg_genes <- as.vector(unique(genfo$gene_name))

plot(density(genfo$GC_content), lwd = 2, main = "", xlab = "GC content", xlim = c(0.25,0.75))
```
####Select GC thresholds.

```{r, results = FALSE}
plot(density(genfo$GC_content), 
     lwd  = 2, 
     main = paste0("GC content of genes in ", genome, " genome"), 
     xlab = "log2 gene length",
     xlim = c(0.25,0.75)
     )

thresholds <- c(
  very_low  = 0.35, 
  low       = 0.4, 
  high      = 0.5, 
  very_high = 0.55, 
  vv_high   = 0.6
)

more_less <- c(
  very_low  = "less", 
  low       = "less", 
  high      = "more", 
  very_high = "more", 
  vv_high   = "more"
)

sapply(names(thresholds), function(x){
  colours <- as.factor(more_less)
  abline(v = thresholds[x], col = colours[x], lwd = 2, lty = 2)
})
```


```{r highlight_density, fig.height = 6, results = FALSE, fig.width = 10}
par(mfrow = c(2, 3))

dens <- density(genfo$GC_content)

sapply(names(thresholds), function(category_filter){
#browser()
  plot(dens, 
       lwd  = 2, 
       xlab = "GC content", 
       xlim = c(0.25,0.75),
       main = ""
  )
  
  if (more_less[category_filter] == "less") {

    filt <- dens$x < thresholds[category_filter]
    polygon(
      c(dens$x[filt], thresholds[category_filter]), 
      c(dens$y[filt], 0), 
      col = 1
    )
    n_genes <- sum(genfo$GC_content < thresholds[category_filter])
    label_text <- paste0("n = ", n_genes)
    text(x = 0.3, y = 4, labels = label_text, cex = 1.5, col = 1, font = 2)
  
    } else {
    
    filt <- dens$x > thresholds[category_filter]
    polygon(
      c(dens$x[filt], thresholds[category_filter]), 
      c(dens$y[filt], 0), 
      col = 2
    )
    n_genes <- sum(genfo$GC_content > thresholds[category_filter])
    label_text <- paste0("n = ", n_genes)
    text(x = 0.65, y = 4, labels = label_text, cex = 1.5, col = 2, font = 2)
  }

})  

```

###Further pre-processing: Generating the biased gene lists

###Generating the biased gene lists within R

```{r generate_gene_lists}
GC_genelists <- lapply(names(thresholds), function(category){

  if (more_less[category] == "less") {
    filtered_genes <- genfo$gene_name[genfo$GC_content < thresholds[category]]
  }
  else{
    filtered_genes <- genfo$gene_name[genfo$GC_content > thresholds[category]]
  }
  sapply(1:100, function(i){
    filtered_genes[ceiling(runif(200, min = 0, max = length(filtered_genes) - 1))]
  })
})  

names(GC_genelists) <- names(thresholds)

#save(GC_genelists, file = "M:/temp/GC/GC_genelists.rda")
```

Check they all look right
```{r, fig.height = 7, fig.width = 6}
par(mfrow = c(1, 1))

GC <- lapply(GC_genelists, function(x) {
  genfo$GC_content[match(unlist(x), genfo$gene_name)]
})

boxplot(GC, col = 1)
```


###GO overrepresentation analysis
         
Run the gene lists through a GO overrepresentation analysis.

```{r, eval=FALSE}
go_results <- overrep_test(all_go_categories, GC_genelists[,1], bg_genes)
head(go_results)

GC_results <- lapply(GC_genelists, function(subset){
  
  apply(subset, MARGIN = 2, function(query){
    overrep_test(all_go_categories, query, bg_genes)#, mult_test = FALSE)
  })
})

save(GC_results, file = "M:/GOcategoryStats/data/GC_results.rda")
#save(GC_results, file = "C:/Users/bigginsl/Desktop/temp/GOcategoryStats/data/GC_results.rda")

# this only took a minute or 2 but still worth saving
```

Any categories with 0 significant results can be removed.
```{r}
sapply(GC_results, is.null)

GC_results <- GC_results[!sapply(GC_results, is.null)]
```

We don't want to run the GO analysis each time the document is knitted as it takes
too long. The code was run once and the data saved as an .rda object that can be 
quickly loaded in to the R session.

See how many significant categories were returned for each gene list.
```{r check_results}
ifelse(using_laptop,
       load("C:/Users/bigginsl/Desktop/temp//GOcategoryStats/data/GC_results.rda"),
       load("M:/GOcategoryStats/data/GC_results.rda")
)

number_of_results <- sapply(GC_results, function(x){
  nulls_removed <- x[lapply(x,length) != 0]
  vapply(nulls_removed, nrow, FUN.VALUE = numeric(1))
})  

```

The number of gene sets that returned significant results from the GO 
overrepresentation analysis 
```{r}
sapply(number_of_results, length)
```


The bean plots show the number of categories returned from each gene list.
The null results have been removed.
```{r beanplots, fig.width = 10, fig.height = 6}
par(mfrow = c(1,1))

library(beanplot)
options(scipen = 999) # disable the scientific notation

beanplot(
  number_of_results, 
  what   = c(0,1,0,1), 
  col    = c("#1B9E77","#06086d"), 
  ll     = 0.03, 
  method = "jitter", 
  border = "#06086d",
  las    = 1,
  main   = "number of significant categories per gene list returned from GO analysis"
)
```

Plot out the p and q values

There are loads of results returned for the long genes, we'll plot out the p 
and q values.
```{r p_values, fig.height = 15, results = FALSE}
p_and_q <- lapply(GC_results, function(x){
  pvals <- unlist(sapply(x, `[[`, "pval"))
  qvals <- unlist(sapply(x, `[[`, "adj_pval"))
  data.frame(pvals, qvals)
})

par(mfrow = c(length(p_and_q), 2))


plot_density_highlight <- function(data_values, 
                                   xlabel    = "", 
                                   threshold = 0.05, 
                                   title     = "", 
                                   colour    = 3
                                   ){
  
  dens <- density(data_values)
  filt <- dens$x < threshold 
  
  plot(dens, 
    main = title, 
    xlab = xlabel,
    ylim = c(0, max(dens$y) * 1.2) 
  )
  polygon(
      c(dens$x[filt], threshold), 
      c(dens$y[filt], 0), 
      col = colour
    )
  text_label = paste0("n = ", sum(data_values < threshold))
  text(dens$x[length(dens$x)/10], 
       y = max(dens$y) * 1.1, 
       labels = text_label, 
       font = 2, 
       col  = "red2"
       )
}

sapply(names(p_and_q), function(x) {  
  
  x_suffix <- paste0("values, N = ", nrow(p_and_q[[x]]))
  
  plot_density_highlight(p_and_q[[x]]$pvals, 
                         title  = x, 
                         xlabel = paste0("p ", x_suffix)
  )

  plot_density_highlight(p_and_q[[x]]$qvals, 
                         title  = x, 
                         xlabel = paste0("corrected p ", x_suffix)
  )
})

```

```{r}
ordered_categories <- lapply(GC_results, function(length_subset){
  
  all_sig_categories <- unlist(sapply(length_subset, rownames))
  tabled_categories  <- table(all_sig_categories)
  tabled_categories[order(tabled_categories, decreasing = TRUE)]
})

#lapply(ordered_categories, head, n = 10)
```

beanplot didn't work
Error in bw.SJ(x, method = "dpi") : sample is too sparse to find TD

```{r}
# convert list of table to list of vectors
convert_tbl_vec <- function(list_of_tables){
  list_of_vec <- lapply(names(list_of_tables), function(x){
  
    vector <- as.vector(list_of_tables[[x]])
    names(vector) <- names(list_of_tables[[x]])
    vector
  })
  names(list_of_vec) <- names(list_of_tables)
  list_of_vec
}
```


```{r boxplot, fig.width = 10}
par(mfrow = c(1,1))
ordered_categories_vec <- convert_tbl_vec(ordered_categories) 
#ordered_categories_vec <- ordered_categories_vec[match(chr_order, names(ordered_categories_vec))]

boxplot(ordered_categories_vec, 
        main = "number of times a GO category appeared during the 100 tests",
        ylab = "no of times GO category appeared",
        xlab = "GC category",
        pch = 16,
        cex = 0.5,
        col = 1,
        cex.axis = 0.8,
        ylim = c(0, 110)
        )

text(1:22, 
     y   = 108, 
     cex = 0.8, 
     col = 1,
     labels = sapply(ordered_categories_vec, length)
     )
```


Replot just showing the data for categories that appeared >= 10 times

```{r}
filtered_categories <- lapply(ordered_categories, function(x) x[x >= 10])

filtered_categories_vec <- convert_tbl_vec(filtered_categories) 

boxplot(filtered_categories_vec,
        main = "GO category appearances (>10)",
        ylab = "no of times GO category appeared",
        xlab = "GC",
        pch  = 16,
        cex  = 0.5,
        col  = 1,
        cex.axis = 0.8,
        ylim = c(10, 110)
        )

text(1:22, 
     y   = 108, 
     cex = 0.8, 
     col = 2,
     labels = sapply(filtered_categories_vec, length)
     )
        
```


Create a dataset that contains these suspect set of categories
```{r}
suspects <- lapply(ordered_categories, function(x) names(x[x >= 10]))  

sapply(suspects, length)
```  

We don't need empty files so remove GC categories with no results.
```{r}
suspects <- suspects[sapply(suspects, length) > 0]
sapply(suspects, length)
```

Deduplicate
```{r}
print_overlaps <- function(set1, set2, not_in = FALSE) {
  ifelse(
    not_in, 
    print(sum(!set1 %in% set2)), 
    print(sum(set1 %in% set2))
  )
}

with(suspects, {
  print_overlaps(very_low, low)
})
```

There are `r print_overlaps(suspects$very_low, suspects$low)` overlapping categories
between very low and low so I'll remove them from the very low category.
```{r}
suspects$very_low <- with(suspects, very_low[!very_low %in% low])
sapply(suspects, length)
```

```{r}
#, eval=FALSE}
# write out file with unix line endings
for (i in 1:length(suspects)) {

  ifelse(using_laptop,
         filename <- paste0("C:/Users/bigginsl/Desktop/temp/biased_gene_lists/identified_categories/GC_", names(suspects)[i], ".txt"),
         filename <- paste0("M:/biased_gene_lists/identified_categories/GC_", names(suspects)[i], ".txt")
  )
  output_file <- file(filename, "wb")
  
  write.table(
    file      = output_file,
    x         = suspects[[i]], 
    row.names = FALSE,
    col.names = FALSE, 
    quote     = FALSE
  )
  
  close(output_file)
}
```
  
  

Didn't get any significant categories using GC > 0.55 or 0.6, though I did before 
- it may be that the filters such as the max number of genes is too strict?

`for i in {1..100}; do ../filter_gene_info.pl --max_GC 0.6 ../Mus_musculus.GRCm38.94_gene_info.txt` 
`--number_of_genes 200 --output_file highGC_0.6_${i}; done`

Extract the gene names and remove header
`for i in highGC*; do cut -f2 $i | tail -n 200 > ${i}_just_genes.txt; done`
