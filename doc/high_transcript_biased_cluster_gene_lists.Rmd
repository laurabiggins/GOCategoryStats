---
title: "high transcript biases"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_knit$set(global.par = TRUE)
```


```{r}
library("devtools")
#load_all("C:/Users/bigginsl/Desktop/temp/GOcategoryStats")
load_all("M:/GOcategoryStats")
par(mgp = c(2, 0.5, 0))
par(mar = par()$mar * 0.7)
library(RColorBrewer)
palette(brewer.pal(6, "Paired"))

genome <- "Mus_musculus.GRCm38.94"
```

Generate lists of mouse genes by number of transcripts.

###Pre-processing of data on cluster

See closest_gene.Rmd - the generation of the genfo file was the same.
We can use the genfo file created from that processing to generate the biased gene
lists.

It can also be imported in to the R session so that we can plot the distribution 
of the number of transcripts per gene in the `r genome` genome.

###Number of transcripts per gene in `r genome`
```{r}
#genfo <- read.delim("C:/Users/bigginsl/Desktop/temp//biased_gene_lists/Mus_musculus.GRCm38.94_gene_info.txt")
genfo <- read.delim("M:/biased_gene_lists/Mus_musculus.GRCm38.94_gene_info.txt")

hist(genfo$no_of_transcripts, 
     main = paste0("number of transcripts per gene in ", genome), 
     xlab = "number of transcripts", 
     col = 1
     )
```

As expected, most genes have very low numbers of transcripts, so we don't get much
information from this plot. We can look at the information in a table format to 
get actual numbers.

```{r}
table(genfo$no_of_transcripts)
```

`r ceiling(table(genfo$no_of_transcripts)["1"] / sum(genfo$no_of_transcripts) *100)`% 
of genes only have one transcript. 
`r ceiling(table(genfo$no_of_transcripts)["2"] / sum(genfo$no_of_transcripts) *100)`% 
of genes have two transcripts. 
I'm not interested in these so I'll replot the data and see how it looks without 
these values.
Above 40 there are only a couple of genes so this can be removed from the plot to 
see it better

```{r, fig.width = 10}
hist(genfo$no_of_transcripts[genfo$no_of_transcripts > 2], 
     main = paste0("number of transcripts (> 2) per gene in ", genome), 
     xlab = "number of transcripts (> 2)",
     breaks = 24,
     col = 1,
     xlim = c(3, 30)
     )
```

```{r}
sum(genfo$no_of_transcripts >= 10)
sum(genfo$no_of_transcripts >= 15)
sum(genfo$no_of_transcripts >= 20)
```

As there are only `r sum(genfo$no_of_transcripts > 20)` genes with more that 20
transcripts, I won't include this category as the gene lists I'm using contain 
200 genes.

###Generating the biased gene lists within R

this is now >= so may be slightly different, not sure if it was just > in the 
cluster generated sets. It may actually be the same as I think there were 174 genes 
in the min20 set before.
```{r generate_gene_lists}
all_min10 <- genfo$gene_name[genfo$no_of_transcripts >= 10]
all_min15 <- genfo$gene_name[genfo$no_of_transcripts >= 15]

min10_res <- sapply(1:100, function(i){
  all_min10[ceiling(runif(200, min = 0, max = length(all_min10) - 1))]
})

min15_res <- sapply(1:100, function(i){
  all_min15[ceiling(runif(200, min = 0, max = length(all_min15) - 1))]
})

```


Check they all look right
```{r, fig.height=9}
head(genfo[match(min10_res[,5], genfo$gene_name),])
tail(genfo[match(min10_res[,12], genfo$gene_name),])
head(genfo[match(min15_res[,28], genfo$gene_name),])
tail(genfo[match(min15_res[,73], genfo$gene_name),])
```



###Further pre-processing: Generating the biased gene lists

Filter the gene info/genfo file for high number of transcripts using the `filter_gene_info.pl`
script that's in github.

`wget https://raw.githubusercontent.com/laurabiggins/biases/master/processing/in_silico/filter_gene_info.pl`


working directory and location of files: 
/bi/group/bioinf/Laura_B/bias_analysis/in_silico/in_silico_datasets

`for i in {1..100}; do ../filter_gene_info.pl --min_transcripts 10 ../Mus_musculus.GRCm38.94_gene_info.txt --number_of_genes 200 --output_file min10_transcripts_${i}; done`

Extract the gene names and remove header         
`for i in min*; do cut -f2 $i | tail -n 200 > ${i}_just_genes.txt; done`

##R analysis       

Import the biased gene lists.     
```{r}
all_transcript_files <- list.files(
  path = "M:/biased_gene_lists/gene_lists/transcripts", 
  pattern = "just_genes.txt", 
  full.names = TRUE
)

min10_indices <- sapply(all_transcript_files, grepl, pattern = "min10") 
min15_indices <- sapply(all_transcript_files, grepl, pattern = "min15") 
min20_indices <- sapply(all_transcript_files, grepl, pattern = "min20") 

min10 <- lapply(all_transcript_files[min10_indices], function(x) scan(x, what = "character"))
min15 <- lapply(all_transcript_files[min15_indices], function(x) scan(x, what = "character"))
min20 <- lapply(all_transcript_files[min20_indices], function(x) scan(x, what = "character"))

biased_transcripts <- list(min10 = min10, min15 = min15)

```

Check they all look right
```{r, fig.height = 5, fig.width = 7}
par(mfrow = c(1, 1))

transcript_numbers <- lapply(biased_transcripts, function(x) {
  y <- unique(unlist(x))
  names <- match(toupper(y), toupper(genfo$gene_name))
  genfo$no_of_transcripts[names]
})

boxplot(transcript_numbers, col = 1)

```

###GO overrepresentation analysis
         
Run the gene lists through a GO overrepresentation analysis.

```{r, eval=FALSE}
transcript_results <- lapply(biased_transcripts, function(transcript_subset){
  
  lapply(transcript_subset, function(query){
    overrep_test(all_go_categories, query, bg_genes)#, mult_test = FALSE, pval_threshold = 0.01)
  })
})

save(transcript_results, file = "M:/GOcategoryStats/data/transcript_results.rda")
# this only took a minute or 2 but still worth saving
```
  
We don't want to run the analysis each time the document is knitted as it takes
too long. The code was run once and the data saved as an .rda object that can be 
quickly loaded in to the R session.
 
See how many significant categories were returned. 
```{r}
#load("C:/Users/bigginsl/Desktop/temp//GOcategoryStats/data/transcript_results.rda")
load("M:/GOcategoryStats/data/transcript_results.rda")

number_of_results <- lapply(transcript_results, function(x){
  nulls_removed <- x[lapply(x,length) != 0]
  vapply(nulls_removed, nrow, FUN.VALUE = numeric(1))
})  

```

The number of sets of genes in each category 
```{r}
sapply(biased_transcripts, length)
```

The number of gene sets that returned significant results from the GO 
overrepresentation analysis 
```{r}
sapply(number_of_results, length)
```

The bean plots show the number of categories returned from each gene list.
The null results have been removed.
```{r beanplots, fig.width = 10, fig.height = 8}
library(beanplot)
options(scipen = 999) # disable the scientific notation

beanplot(
  number_of_results[1:2], 
  what   = c(0,1,0,1), 
  col    = c("#1B9E77","#06086d"), 
  ll     = 0.03, 
  method = "jitter", 
  border = "#06086d",
  las    = 1,
  main   = "number of significant categories per gene list returned from GO analysis"
)
```
There are fewer that 200 genes that have more than 20 transcripts so there is no 
point repeating the GO analysis for the min 200 category. 
Almost all the results from the min20 set were in the min15 results

          
Plot out the p and q values.
```{r p_values, fig.height = 8, results = FALSE}
p_and_q <- lapply(transcript_results, function(x){
  pvals <- unlist(sapply(x, `[[`, "pval"))
  qvals <- unlist(sapply(x, `[[`, "adj_pval"))
  data.frame(pvals, qvals)
})

par(mfrow = c(3, 2))

plot_density_highlight <- function(data_values, 
                                   xlabel    = "", 
                                   threshold = 0.05, 
                                   title     = "", 
                                   colour    = 1
                                   ){
  
  dens <- density(data_values)
  filt <- dens$x < threshold 
  
  plot(dens, 
    main = title, 
    xlab = xlabel,
    ylim = c(0, max(dens$y) * 1.2) 
  )
  polygon(
      c(dens$x[filt], threshold), 
      c(dens$y[filt], 0), 
      col = colour
    )
  text_label = paste0("n = ", sum(data_values < threshold))
  text(dens$x[length(dens$x)/10], 
       y = max(dens$y) * 1.1, 
       labels = text_label, 
       font = 2, 
       col  = "red2"
       )
}

sapply(names(p_and_q), function(x) {  
  
  x_suffix <- paste0("values, N = ", nrow(p_and_q[[x]]))
  
  plot_density_highlight(p_and_q[[x]]$pvals, 
                         title  = x, 
                         xlabel = paste0("p ", x_suffix)
  )

  plot_density_highlight(p_and_q[[x]]$qvals, 
                         title  = x, 
                         xlabel = paste0("corrected p ", x_suffix)
  )
})

#x_suffix <- paste0("values, N = ", nrow(min20_results))

#plot_density_highlight(min20_results$pval, xlabel = paste0("corrected p ", x_suffix), title = "min20")
#plot_density_highlight(min20_results$adj_pval, xlabel = paste0("corrected p ", x_suffix), title = "min20")

```


```{r}
ordered_categories <- lapply(transcript_results, function(transcript_subset){
  
  all_sig_categories <- unlist(sapply(transcript_subset, rownames))
  tabled_categories  <- table(all_sig_categories)
  tabled_categories[order(tabled_categories, decreasing = TRUE)]
})

lapply(ordered_categories, head, n = 5)
```

Plot how many times a category appeared.
```{r, fig.height=3, results=FALSE}
par(mfrow = c(1,2))
sapply(names(ordered_categories), function(x){
  plot(density(ordered_categories[[x]]), main = x)
})
```

```{r beanplot2}
par(mfrow = c(1,1))

beanplot(
  ordered_categories, 
  what   = c(0,1,0,1), 
  col    = c("#1B9E77","#06086d"), 
  ll     = 0.02, 
  method = "jitter", 
  border = "#06086d",
  las    = 1,
  log    = "",
  ylim   = c(0, 120),
  main  = "number of times a GO category appeared during the 100 tests",
  ylab  = "no of times GO category appeared"
)

text(1:length(ordered_categories), 
     y   = 115, 
     cex = 0.8, 
     labels = paste0("n = ", sapply(ordered_categories, length))
     )


```

Replot just showing the data for categories that appeared >= 10 times
```{r beanplot_filtered}
filtered_categories <- lapply(ordered_categories, function(x) x[x >= 10])

beanplot(
  filtered_categories, 
  what   = c(0,1,0,1), 
  col    = c("#1B9E77","#06086d"), 
  ll     = 0.03, 
  method = "jitter", 
  border = "#06086d",
  las    = 1,
  log    = "",
  ylim   = c(10, 120),
  main   = "GO category appearances (>10)",
  ylab   = "no of times GO category appeared"
)

text(1:length(filtered_categories), 
     y   = 115, 
     cex = 0.8, 
     labels = paste0("n = ", sapply(filtered_categories, length))
     )

```


Now we could do with some stats to pick a cutoff for the number of times a 
category appears. Let's just select an arbitrary value for now....

The top suspects from min 20 are all in min15 so I'll leave min20 for now.

Create a dataset that contains these suspect set of categories
```{r}
suspects <- lapply(ordered_categories, function(x){
  names(x[x >= 30])
})  

```  

```{r}
print_sums <- function(set1, set2, not_in = FALSE) {
  ifelse(
    not_in, 
    print(sum(!set1 %in% set2)), 
    print(sum(set1 %in% set2))
  )
}

with(suspects, {
  print_sums(min15, min10)
  print_sums(min15, min10, TRUE)
  print_sums(min10, min15, TRUE)
})

#print_sums(head(rownames(min20_results), n = 200), suspects$min15)
```
There are `r print_sums(suspects$min15, suspects$min10)` categories that appear in both the 
min10 and min15 sets. I'll remove them from the min15 set.

```{r, eval = FALSE}
suspects$min15 <- suspects$min15[!suspects$min15 %in% suspects$min10]

save(suspects, file = "M:/GOcategoryStats/data/suspects_high_transcripts.rda")
```  


```{r, eval=FALSE}
# write out file with unix line endings
for (i in 1:length(suspects)){
  
  filename <- paste0("M:/biased_gene_lists/identified_categories/", names(suspects)[i], "transcripts.txt")
  output_file <- file(filename, "wb")
  
  write.table(file = output_file, 
              x = suspects[[i]], 
              row.names = FALSE,
              col.names = FALSE, 
              quote = FALSE)
  
  close(output_file)
}
```
  
